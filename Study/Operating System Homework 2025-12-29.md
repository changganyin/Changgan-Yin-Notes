# 第7章 存储管理习题 - 答案与解析

## 一、 判断题 (1-20)

1. Cache是三级存储体系中速度最快，容量最大的一类。
* 答案：× (错)
* 解析：在存储体系中，Cache（高速缓存）的速度是最快的，但容量是最小的。容量最大、速度最慢的是辅存（硬盘）；内存介于两者之间。

2. 固定地址映射由程序员或编译器完成地址映射，容易产生地址冲突，运行失败。
* 答案：√ (对)
* 解析：固定地址映射（静态重定位的一种形式）通常在程序运行前确定物理地址。如果多个程序争用同一块物理地址，就会发生冲突，导致无法同时运行。

3. 存储保护功能是指防止访问越界和防止访问越权。
* 答案：√ (对)
* 解析：这是存储保护定义的标准描述。系统必须确保进程只能访问分配给它的内存区域（防越界），且必须按照规定的权限（读/写/执行）进行访问（防越权）。

4. 静态地址映射和动态地址映射计算物理地址时都是用虚拟地址加上基址。
* 答案：× (错)
* 解析：静态地址映射是在程序装入时由加载器完成重定位，物理地址直接生成，运行时不再计算。动态地址映射则是在运行时由硬件（MMU）将逻辑地址与基址寄存器相加。两者的机制和时机完全不同。

5. 虚拟内存管理的目标之一是使得大的程序能在较小的内存中运行。
* 答案：√ (对)
* 解析：虚拟内存的核心优势就是“小内存运行大程序”。通过将暂时不用的数据换出到辅存（如硬盘），只保留当前活跃的页面在内存中。

6. 采用固定分区的系统在程序装入前，内存已被分区，且每个分区大小都相同，不在改变。
* 答案：× (错)
* 解析：虽然固定分区是在系统启动或装入前分区且不再改变，但分区大小可以相同，也可以不同。题目中说“每个分区大小都相同”过于绝对，忽略了“分区大小不等”的固定分区方案。

7. 动态分区容易产生碎片。
* 答案：√ (对)
* 解析：动态分区分配会随着进程的频繁装入和撤销，在内存中产生许多细小的、不连续的空闲块，这些无法被利用的小块称为外部碎片。

8. 内存碎片是指内存损坏而导致不能使用的区域。
* 答案：× (错)
* 解析：内存碎片是指未被分配但也无法被利用的空闲内存区域（因为太小或不连续），并不是指物理硬件损坏。

9. 在页式地址映射过程中，快表的作用是尽量减少内存访问次数。
* 答案：√ (对)
* 解析：快表（TLB）缓存了页表项。当TLB命中时，CPU可以直接获得物理地址，避免了访问内存中的页表，从而将访存次数从两次（或更多）减少为一次。

10. 缺页中断处理程序的作用就是把相应页面的数据从写入到硬盘中。
* 答案：× (错)
* 解析：缺页中断的主要作用是将缺失的页面从硬盘调入（读入）到内存中。写入硬盘通常发生在页面被置换且该页面被修改过（Dirty）的时候。

11. 最佳算法（OPT算法）淘汰以后不再需要或最远的将来才会用到的页面，是实际应用中性能最好的淘汰算法。
* 答案：× (错)
* 解析：虽然OPT算法理论上缺页率最低，但因为它需要预知未来哪些页面会被访问，这在实际应用中是无法实现的。题目称其为“实际应用中”最好是错误的。

12. 采用内存覆盖技术存储系统，调入一个模块时可以临时将其随意将其放在一个足够大的覆盖区上。
* 答案：× (错)
* 解析：覆盖技术需要程序员显式定义覆盖结构（哪些模块共享哪个内存区域），不能“随意”放置，必须遵循预定义的互斥关系。

13. 使用内存交换技术可以增加进程并发数。
* 答案：√ (对)
* 解析：交换技术可以将暂时阻塞或低优先级的进程换出到外存，腾出宝贵的物理内存空间给新进程或就绪进程，从而提高系统的并发程度。

14. 提高程序的局部性可以有效降低系统的缺页率。
* 答案：√ (对)
* 解析：局部性好意味着程序在一段时间内集中访问某部分数据，减少了频繁跳转和页面调度的需求，从而显著降低缺页率。

15. 段页式系统的地址映射过程需要既需要段表，也需要页表，而且段表和页表都需要多个。
* 答案：√ (对)
* 解析：每个进程有一个段表，而每个段可能对应一个独立的页表，因此一个进程会有多个页表。从系统整体看，确实需要多个段表（多进程）和多个页表。

16. 控制寄存器CR0的PG位作用是控制实模式和保护模式的选择。
* 答案：× (错)
* 解析：CR0的PG位用于控制分页机制（Paging）的开启与关闭。控制实模式和保护模式切换的是PE位（Protection Enable）。

17. 保护模式下，CS，DS存储的是相应段的基址。
* 答案：× (错)
* 解析：在保护模式下，CS、DS等段寄存器存储的是选择子（Selector）。CPU使用选择子在描述符表中查找段描述符，真正的段基址存储在描述符中。

18. 描述符表（Descriptor Table）以8字节为单位存储段的描述符。
* 答案：√ (对)
* 解析：在x86架构下，段描述符是64位（即8字节）的数据结构。

19. 选择子作用是选择描述符表中某个描述符。
* 答案：√ (对)
* 解析：选择子（Selector）本质上是一个索引，用于指向全局描述符表（GDT）或局部描述符表（LDT）中的特定条目。

20. 二级页表机制中，页表和页目录大小都是4K。
* 答案：√ (对)
* 解析：在标准的x86 32位分页中，页大小为4KB。页目录和页表都包含1024项，每项4字节，总大小正好是 1024 * 4B = 4KB。

## 二、 填空题 (21-40)

21. 地址映射是指把把程序中的地址虚拟地址变换成【物理（或 内存）】的真实地址的过程。
* 解析：内存管理的核心机制，将逻辑（虚拟）地址映射到物理内存地址，以便CPU能访问实际的物理单元。

22. 分区存储管理包括固定分区和【动态分区】两种。
* 解析：分区管理主要分为静态（固定）和动态（可变）两种方式。

23. 按空闲区位置（首址）递增排序的放置策略叫【首次（First Fit）】适应算法。
* 解析：首次适应算法总是从低地址开始查找，只要找到第一个足够大的空闲区就分配，因此要求空闲链表按地址递增排序。

24. 按空闲区大小的递增排序的放置策略叫【最佳（Best Fit）】适应算法。
* 解析：最佳适应算法倾向于使用“最合适”（即大小最小且够用）的空闲区，因此需要按大小从小到大排序。

25. 尽量保留较大空闲区的放置策略叫【最坏（Worst Fit）】适应算法。
* 解析：最坏适应算法总是分配最大的空闲区，切分后剩下的部分仍可能较大，适合后续大进程分配。这需要按空闲区大小从大到小排序。

26. 页面放置策略中，最容易产生页面碎片的算法是【最佳（Best Fit）】适应算法。
* 解析：最佳适应算法每次都选大小最接近的空闲区，导致切分后剩余下来的碎片非常小，难以被再次利用，从而产生最多的外部碎片。

27. 虚拟内存管理的实现思路用到了程序运行的【局部性】原理，即程序在一个有限的时间段内访问的代码和数据往往集中在有限的地址范围内。
* 解析：时间局部性和空间局部性是虚拟存储器能够实现“按需调页”的理论基础。

28. 页式内存管理方案中，内存以【页（或 页面/页框/块）】为单位分配使用。
* 解析：在分页系统中，物理内存被划分为固定大小的块（页框），逻辑空间被划分为同样大小的块（页）。

29. 假定虚拟地址是20200505，页面大小是4K字节。则该地址所在页号是【20200】。
* 解析：4K = 2^12，即16进制地址的最后3位是页内偏移，前面部分是页号。地址 0x20200505 右移 12 位即得 0x20200。

30. 假定虚拟地址是20200505，页面大小是4K字节。则该地址的页内偏移是【505】。
* 解析：页内偏移是地址的低12位。即 0x20200505 & 0xFFF = 0x505。

31. 记录页面和页框之间对应关系的数据结构叫【页表】。
* 解析：页表的作用就是建立逻辑页号到物理页框号的映射。

32. 页面共享原理是在不同进程的页表中填上相同的【物理页框号（或 物理块号）】，使得多个进程能访问相同的内存空间，从而实现页面共享。
* 解析：如果两个不同进程的页表项指向同一个物理内存地址（页框），它们就共享了该页面。

33. 在地址映射过程中，当所要访问的目的页不在内存时，系统产生的中断叫【缺页中断】。
* 解析：这是请求分页系统的核心机制，触发操作系统挂起当前进程，去硬盘调入页面。

34. 好的淘汰策略应具有较低的【缺页率】且页面抖动较少。
* 解析：缺页率直接影响系统性能，缺页率越低，CPU用于处理中断的时间越少，系统效率越高。

35. 淘汰最长时间未被使用的页面的淘汰策略叫【LRU】算法。
* 解析：LRU (Least Recently Used) 即最近最久未使用算法，利用局部性原理预测未来。

36. 段表记录每段在内存中映射的位置，包括段号，【段长（或 段界限）】，段基地址等三个基本要素。
* 解析：段表项通常包含段基址（起始位置）和段长（用于防止越界访问）。

37. 采用二级页表的页式内存管理（不考虑快表）时，访问一个数据需要访问【3】次内存才能最终获得存取数据。
* 解析：第一次访问页目录，第二次访问页表，第三次访问实际物理地址的数据。共3次。

38. 如果发生缺页，引发缺页的线性地址保存在【CR2】寄存器中。
* 解析：x86架构下，CR2寄存器专门用于存储导致缺页异常（Page Fault）的线性地址，供中断处理程序使用。

39. 在CR3寄存中包含有页目录基址的高【20】位。
* 解析：页目录地址必须4K对齐（低12位为0），因此CR3只需要存储高20位基址即可确定页目录位置。

40. X86 CPU 架构下，逻辑地址先转化为【线性地址】，再转化为物理地址。
* 解析：逻辑地址（段式：Segment:Offset）经过分段单元（Segmentation Unit）转化为线性地址。如果开启了分页，线性地址再经过分页单元（Paging Unit）转化为物理地址。