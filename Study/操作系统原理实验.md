## 实验一
### task_1 编译新内核
1. 从 kernel.org 下载新内核
2. 安装乱七八糟的包
3. sudo make menuconfig 打开配置内核的图形界面，然后 Save Exit
4. 修改 .config：`CONFIG_SYSTEM_TRUSTED_KEYS=""`, `CONFIG_SYSTEM_REVOCATION_KEYS=""`
5. make -j16 编译
6. make modules_install 安装 modules
7. make install 安装内核

### task_2 添加新系统调用
- 旧内核版本：6.14.0.37-generic
- 新内核版本：6.17.12

修改三个文件：
- arch/x86/entry/syscalls/syscall_64.tbl
```tbl
548 common Max    sys_Max
549 common GetPID sys_GetPID
550 common GetCMD sys_GetCMD
```

- include/linux/syscalls.h
```h
asmlinkage long sys_Max(int a, int b, int c);
asmlinkage long sys_GetPID(void);
asmlinkage long sys_GetCMD(char __user *buf, int len);
#endif
```

- kernel/sys.c
```c
// 1. Max: 比较三个整数，返回最大值
SYSCALL_DEFINE3(Max, int, a, int, b, int, c)
{
    int max = a;
    if (b > max) max = b;
    if (c > max) max = c;

    printk(KERN_INFO "[MyCall] Max(%d, %d, %d) = %d\n", a, b, c, max);
    return max;
}

// 2. GetPID: 获得当前进程 ID
SYSCALL_DEFINE0(GetPID)
{
    printk(KERN_INFO "[MyCall] GetPID called. PID: %d\n", current->pid);
    return current->pid;
}

// 3. GetCMD: 获得当前进程名称
SYSCALL_DEFINE2(GetCMD, char __user *, buf, int, len)
{
    // 定义一个内核栈上的临时缓冲区
    // TASK_COMM_LEN 通常是 16，定义在 <linux/sched.h> 中
    char comm[TASK_COMM_LEN];
    int comm_len;

    get_task_comm(comm, current);

    // 2. 计算长度
    comm_len = strlen(comm) + 1;

    // 3. 检查用户缓冲区大小
    if (len < comm_len)
        return -EINVAL;

    // 4. 从“内核栈”拷贝到“用户空间”，这是被允许的
    if (copy_to_user(buf, comm, comm_len))
        return -EFAULT;

    return 0;
}
/* --- My Custom System Calls End --- */
```

### task_4 显示系统信息
sys_monitor.sh
```bash
#!/bin/bash

# 定义颜色变量，为了让输出好看一点
# 用 ANSI 转义码来实现彩色高亮
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m' # No Color，用完颜色记得清除，不然会乱

echo -e "${BLUE}${BOLD}=== Linux系统监测脚本运行报告 ===${NC}"
echo "----------------------------------------"

# ================= 1. 系统基本信息部分 =================
echo -e "${GREEN}${BOLD}1. 系统基本信息部分${NC}"

# 1. 获取系统名称
# 有的系统没有 lsb_release，所以先读文件试试，不行再用 uname
if [ -f /etc/os-release ]; then
    # 读取配置文件里的变量
    source /etc/os-release
    echo "系统名称: $PRETTY_NAME"
else
    echo "系统名称: $(uname -s)"
fi

# 2. 内核版本
echo "内核版本: $(uname -r)"

# 3. 运行时间
# 使用 -p 参数让时间显示更人性化 (pretty format)
echo "运行时间: $(uptime -p)"

# 4. 当前用户
# id -u 可以查到用户的 UID，whoami 查名字
echo "当前用户: $(whoami) (UID: $(id -u))"

# 5. CPU信息
# 直接去 /proc/cpuinfo 里 grep 找型号，uniq 去重只显示一行
# xargs 用来去除多余的空格
CPU_MODEL=$(grep 'model name' /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)
# 统计 processor 出现的次数就知道有几个核了
CPU_CORES=$(grep -c 'processor' /proc/cpuinfo)
echo "CPU信息 : $CPU_MODEL ($CPU_CORES 核心)"

# 6. 内存信息
# 注意：这里加了 LC_ALL=C，强制命令输出英文，
# 否则如果系统是中文环境，grep "Mem" 可能会失败，导致变量为空报错
MEM_TOTAL=$(LC_ALL=C free -h | grep Mem | awk '{print $2}')
MEM_USED=$(LC_ALL=C free -h | grep Mem | awk '{print $3}')
MEM_AVAIL=$(LC_ALL=C free -h | grep Mem | awk '{print $7}')
echo "内存信息: 总共 $MEM_TOTAL, 已用 $MEM_USED, 可用 $MEM_AVAIL"

echo ""

# ================= 2. 系统状态部分 =================
echo -e "${GREEN}${BOLD}2. 系统状态部分${NC}"

# 1. 系统负载
# 直接读取 /proc/loadavg 文件的系统平均负载数据
LOAD_AVG=$(awk '{print $1", "$2", "$3}' /proc/loadavg)
echo "系统负载: $LOAD_AVG (1, 5, 15分钟)"

# 2. 当前时间
echo "当前时间: $(date "+%Y年%m月%d日 %H点%M分%S秒")"

# 3. CPU使用率
# 用 top 抓取一次状态 (-bn1)，然后用 sed 提取 id (idle 空闲率)
# 只要算出空闲率，用 100 减去它就是使用率了
CPU_IDLE=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print $1}')
# 判断一下是否获取到了数值，防止计算报错
if [ -n "$CPU_IDLE" ]; then
    # 用 bc 或者简单的 shell 算术运算
    # 这里为了兼容性，用 awk 来做减法
    CPU_USAGE=$(awk "BEGIN {print 100 - $CPU_IDLE}")
    echo "CPU使用率: ${CPU_USAGE}%"
else
    echo "CPU使用率: 无法获取"
fi

# 4. 内存使用率
# 为了计算百分比，这里用 bytes 为单位取数值 (free 不带 -h)
# 同样加上 LC_ALL=C 防止出错
MEM_TOTAL_NUM=$(LC_ALL=C free | grep Mem | awk '{print $2}')
MEM_USED_NUM=$(LC_ALL=C free | grep Mem | awk '{print $3}')

# 这里的 awk 用来做浮点数除法运算，保留两位小数
# 加上判断防止分母为 0 的情况
if [ -n "$MEM_TOTAL_NUM" ] && [ "$MEM_TOTAL_NUM" -gt 0 ]; then
    MEM_PERCENT=$(awk "BEGIN {printf \"%.2f\", $MEM_USED_NUM / $MEM_TOTAL_NUM * 100}")
    echo "内存使用率: ${MEM_PERCENT}%"
else
    echo "内存使用率: 无法计算"
fi

echo ""

# ================= 3. 进程信息部分 =================
echo -e "${GREEN}${BOLD}3. 进程信息部分${NC}"

# 使用 ps 命令自定义输出格式：PID, 用户, CPU占用, 内存占用, 命令名
# --sort 参数用来排序，-pcpu 表示按 CPU 降序，-pmem 表示按内存降序

echo -e "${BOLD}CPU占用最高的5个进程:${NC}"
# head -n 6 是因为第一行是标题，所以取前6行就是 Top 5
ps -eo pid,user,pcpu,pmem,comm --sort=-pcpu | head -n 6 | awk '{printf "%-8s %-10s %-8s %-8s %s\n", $1, $2, $3"%", $4"%", $5}'

echo ""
echo -e "${BOLD}内存占用最高的5个进程:${NC}"
ps -eo pid,user,pcpu,pmem,comm --sort=-pmem | head -n 6 | awk '{printf "%-8s %-10s %-8s %-8s %s\n", $1, $2, $3"%", $4"%", $5}'

echo "----------------------------------------"
```

*实验一截图*
成功截图：
![[Pasted image 20251223153920.png]]

## 实验二
### task_1 在 Linux 下创建两个线程 A 和 B, 循环输出数据或者字符串
task_1.cpp
```cpp
#include <pthread.h>
#include <iostream>
#include <unistd.h>

// 线程 A 的执行函数
void* ThreadAFunc(void* arg) {
    for (int i = 1; i <= 1000; ++i) {
        std::cout << "A:" << i << std::endl;
        usleep(200000); // 暂停 0.2 秒 (200,000 微秒)
    }
    return NULL;
}

// 线程 B 的执行函数
void* ThreadBFunc(void* arg) {
    for (int i = 1000; i >= 1; --i) {
        std::cout << "B:" << i << std::endl;
        usleep(200000); // 暂停 0.2 秒
    }
    return NULL;
}

int main() {
    pthread_t threadA, threadB;

    // 创建线程 A
    if (pthread_create(&threadA, NULL, ThreadAFunc, NULL) != 0) {
        std::cerr << "Error creating thread A" << std::endl;
        return 1;
    }

    // 创建线程 B
    if (pthread_create(&threadB, NULL, ThreadBFunc, NULL) != 0) {
        std::cerr << "Error creating thread B" << std::endl;
        return 1;
    }

    // 等待线程结束
    pthread_join(threadA, NULL);
    pthread_join(threadB, NULL);

    return 0;
}
```
g++ task_1.cpp -o task_1 -lpthread

1. 利用 `pthread` 库同时启动两个线程 A 和 B
2. 线程 A：从 1 累加到 1000
3. 线程 B：从 1000 递减到 1
4. 每个循环均使用 `usleep(200000)` 暂停 **0.2 秒**，使两个线程在控制台交替输出
5. `main` 函数使用 `pthread_join` 等待两个子线程全部执行完毕后才退出

*task_1 截图*
![[Pasted image 20251223154235.png]]

### task_2 在 Linux 下创建父子进程，实现 wait 同步函数，理解父子进程同步
task_2.cpp
```cpp
#include <iostream>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <cstdlib>

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        // Fork 失败
        std::cerr << "Fork failed!" << std::endl;
        return 1;
    } else if (pid == 0) {
        // 子进程代码
        std::cout << "[Child] I am the child process (PID: " << getpid() << ")." << std::endl;
        std::cout << "[Child] Sleeping for 5 seconds..." << std::endl;
        sleep(5);
        std::cout << "[Child] Woke up. Exiting with status 42." << std::endl;
        exit(42); // 子进程返回 42
    } else {
        // 父进程代码
        std::cout << "[Parent] I am the parent process (PID: " << getpid() << ")." << std::endl;
        std::cout << "[Parent] Created child process with PID: " << pid << std::endl;

        int status;
        std::cout << "[Parent] Waiting for child to exit..." << std::endl;

        // 等待任意子进程结束
        pid_t child_pid = wait(&status);

        if (WIFEXITED(status)) {
            // 子进程正常退出
            int exit_status = WEXITSTATUS(status);
            std::cout << "[Parent] Child process " << child_pid << " exited normally." << std::endl;
            std::cout << "[Parent] The return status is: " << exit_status << std::endl;
        } else {
            std::cout << "[Parent] Child process exited abnormally." << std::endl;
        }
    }

    return 0;
}
```
g++ task_2.cpp -o task_2

1. 调用 `fork()` 创建一个与父进程几乎完全一样的子进程。此时程序通过返回值 pid 分流：pid == 0：当前处于子进程环境; pid > 0：当前处于父进程环境（返回值为子进程的 PID）
2. 子进程行为：打印自身 PID 后进入 5 秒休眠，随后通过 `exit(42)` 退出并返回状态码 42
3. **父进程行为**：调用 `wait(&status)` 进入**阻塞状态**，等待子进程结束
4. **状态捕获**：子进程退出后，父进程被唤醒，利用宏 `WIFEXITED` 确认子进程是正常退出的，并用 `WEXITSTATUS` 提取出子进程返回的数值 42

*task_2 截图*
![[Pasted image 20251223154345.png]]

### task_3 在 Windows 下，利用线程实现并发画圆画方
task_3.cpp
```cpp
#include <iostream>
#include <math.h>
#include <windows.h>

#define PI 3.14159265

// 全局变量，用于窗口句柄
HWND hGraphWindow = NULL;

// 窗口过程函数 (处理窗口消息)
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                            LPARAM lParam) {
    switch (uMsg) {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);
        // 这里什么都不做，留给线程去画
        EndPaint(hwnd, &ps);
    }
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

// 专门用于创建和维护窗口的线程
DWORD WINAPI WindowThread(LPVOID lpParam) {
    const char CLASS_NAME[] = "Sample Window Class";
    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = CLASS_NAME;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); // 白色背景

    RegisterClass(&wc);

    hGraphWindow = CreateWindowEx(0, CLASS_NAME, "Concurrent Drawing Lab",
                                  WS_OVERLAPPEDWINDOW | WS_VISIBLE, 100, 100,
                                  800, 600, // 窗口位置和大小
                                  NULL, NULL, GetModuleHandle(NULL), NULL);

    if (hGraphWindow == NULL)
        return 0;

    // 消息循环
    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return 0;
}

// 线程 A：画圆
DWORD WINAPI DrawCircle(LPVOID lpParam) {
    // 等待窗口创建完毕
    while (hGraphWindow == NULL)
        Sleep(10);

    HDC hdc = GetDC(hGraphWindow);
    int centerX = 300;
    int centerY = 300;
    int radius = 100;
    COLORREF color = RGB(255, 0, 0); // 红色

    for (int i = 0; i < 720; ++i) {
        double angle = (double)i * PI / 360.0;
        int x = centerX + (int)(radius * cos(angle));
        int y = centerY + (int)(radius * sin(angle));

        SetPixel(hdc, x, y, color);

        // 画大一点点，防止看不清
        SetPixel(hdc, x + 1, y, color);
        SetPixel(hdc, x, y + 1, color);
        SetPixel(hdc, x + 1, y + 1, color);

        Sleep(2); // 稍微快一点
    }
    ReleaseDC(hGraphWindow, hdc);
    return 0;
}

// 线程 B：画正方形
DWORD WINAPI DrawSquare(LPVOID lpParam) {
    // 等待窗口创建完毕
    while (hGraphWindow == NULL)
        Sleep(10);

    HDC hdc = GetDC(hGraphWindow);
    int centerX = 600;
    int centerY = 300;
    int sideLength = 200;
    int halfSide = sideLength / 2;
    COLORREF color = RGB(0, 0, 255); // 蓝色

    int steps = 180;

    // 定义四个顶点的逻辑
    // 上边
    for (int i = 0; i < steps; i++) {
        int x = (centerX - halfSide) + (int)((double)sideLength * i / steps);
        int y = centerY - halfSide;
        SetPixel(hdc, x, y, color);
        SetPixel(hdc, x + 1, y, color);
        SetPixel(hdc, x, y + 1, color);
        Sleep(2);
    }
    // 右边
    for (int i = 0; i < steps; i++) {
        int x = centerX + halfSide;
        int y = (centerY - halfSide) + (int)((double)sideLength * i / steps);
        SetPixel(hdc, x, y, color);
        SetPixel(hdc, x + 1, y, color);
        SetPixel(hdc, x, y + 1, color);
        Sleep(2);
    }
    // 下边
    for (int i = 0; i < steps; i++) {
        int x = (centerX + halfSide) - (int)((double)sideLength * i / steps);
        int y = centerY + halfSide;
        SetPixel(hdc, x, y, color);
        SetPixel(hdc, x + 1, y, color);
        SetPixel(hdc, x, y + 1, color);
        Sleep(2);
    }
    // 左边
    for (int i = 0; i < steps; i++) {
        int x = centerX - halfSide;
        int y = (centerY + halfSide) - (int)((double)sideLength * i / steps);
        SetPixel(hdc, x, y, color);
        SetPixel(hdc, x + 1, y, color);
        SetPixel(hdc, x, y + 1, color);
        Sleep(2);
    }

    ReleaseDC(hGraphWindow, hdc);
    return 0;
}

int main() {
    // 1. 启动窗口线程
    HANDLE hWinThread = CreateThread(NULL, 0, WindowThread, NULL, 0, NULL);

    std::cout << "Waiting for window..." << std::endl;
    while (hGraphWindow == NULL)
        Sleep(100);
    std::cout << "Window created! Drawing..." << std::endl;

    // 2. 启动画图线程
    HANDLE hThread1 = CreateThread(NULL, 0, DrawCircle, NULL, 0, NULL);
    HANDLE hThread2 = CreateThread(NULL, 0, DrawSquare, NULL, 0, NULL);

    // 等待画图完成
    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    std::cout << "Drawing finished. Close the window to exit." << std::endl;

    // 等待窗口关闭
    WaitForSingleObject(hWinThread, INFINITE);

    return 0;
}
```
g++ .\task_3.cpp -o task_3 -lgdi32

1. 通过 `CreateThread` 启动了一个专门的 `WindowThread` 线程，用于注册窗口类、创建 `HWND` 窗口并运行 `GetMessage` 消息循环
2. 确认窗口句柄 `hGraphWindow` 有效后，同时启动两个绘图线程：`DrawCircle` 线程：利用三角函数 `cos` 和 `sin` 计算坐标，在窗口左侧绘制一个红色圆形；`DrawSquare` 线程：通过四个顺序执行的 `for` 循环计算线性坐标，在窗口右侧绘制一个蓝色正方形
3. 调用 `GetDC` 获取窗口的设备上下文（HDC），并使用 `SetPixel` 逐点打点绘图。通过 `Sleep(2)` 控制绘制速度，展示两个图形同时生长的动画效果
4. `main` 函数利用 `WaitForSingleObject` 阻塞等待两个绘图线程执行完毕

*task_3 截图*
![[Pasted image 20251223154415.png]]

### task_4 在 Linux 下利用线程实现“生产者-消费者”同步控制
task_4.cpp
```cpp
#include <pthread.h>
#include <semaphore.h>
#include <iostream>
#include <vector>
#include <unistd.h>
#include <cstdlib>

#define BUFFER_SIZE 10

// 缓冲区
int buffer[BUFFER_SIZE];
int in = 0;  // 写入位置
int out = 0; // 读取位置

// 信号量和互斥锁
sem_t empty_slots; // 空槽位数量
sem_t full_slots;  // 满槽位数量 (即产品数量)
pthread_mutex_t mutex; // 互斥锁，保护缓冲区

// 生产者线程函数
void* Producer(void* arg) {
    int id = *(int*)arg;
    int start_val = (id == 1) ? 1000 : 2000;
    int end_val = (id == 1) ? 1999 : 2999;

    for (int i = start_val; i <= end_val; ++i) {
        int data = i;

        // 随机睡眠 100ms - 1s
        usleep((rand() % 900000) + 100000);

        // 等待空槽位
        sem_wait(&empty_slots);
        // 获取互斥锁
        pthread_mutex_lock(&mutex);

        // 放入数据
        buffer[in] = data;
        std::cout << "[Producer " << id << "] Produced: " << data << " at index " << in << std::endl;
        in = (in + 1) % BUFFER_SIZE;

        // 释放互斥锁
        pthread_mutex_unlock(&mutex);
        // 增加满槽位信号量
        sem_post(&full_slots);
    }
    return NULL;
}

// 消费者线程函数
void* Consumer(void* arg) {
    int id = *(int*)arg;
    while (true) {
        // 随机睡眠 100ms - 1s
        usleep((rand() % 900000) + 100000);

        // 等待满槽位 (有产品)
        sem_wait(&full_slots);
        // 获取互斥锁
        pthread_mutex_lock(&mutex);

        // 取出数据
        int data = buffer[out];
        std::cout << "    [Consumer " << id << "] Consumed: " << data << " from index " << out << std::endl;
        out = (out + 1) % BUFFER_SIZE;

        // 释放互斥锁
        pthread_mutex_unlock(&mutex);
        // 增加空槽位信号量
        sem_post(&empty_slots);
    }
    return NULL;
}

int main() {
    // 初始化信号量和互斥锁
    sem_init(&empty_slots, 0, BUFFER_SIZE); // 初始空槽位为 10
    sem_init(&full_slots, 0, 0);            // 初始产品数为 0
    pthread_mutex_init(&mutex, NULL);

    pthread_t p1, p2;
    pthread_t c1, c2, c3;
    int id1 = 1, id2 = 2, id3 = 3; // 线程 ID

    // 创建消费者 (先创建消费者或者生产者都可以)
    pthread_create(&c1, NULL, Consumer, &id1);
    pthread_create(&c2, NULL, Consumer, &id2);
    pthread_create(&c3, NULL, Consumer, &id3);

    // 创建生产者
    pthread_create(&p1, NULL, Producer, &id1);
    pthread_create(&p2, NULL, Producer, &id2);

    // 等待生产者结束 (消费者是死循环，这里主线程只等生产者)
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);

    // 清理资源
    sem_destroy(&empty_slots);
    sem_destroy(&full_slots);
    pthread_mutex_destroy(&mutex);

    return 0;
}
```
g++ task_4.cpp -o task_4 -lpthread

1. 利用 `sem_t` 类型的两个信号量 `empty_slots`（空位）和 `full_slots`（产品数）来协调生产与消费的节奏
2. 使用 `pthread_mutex_t` 互斥锁保护共享的循环缓冲区 `buffer` 以及索引变量 `in` 和 `out`。确保同一时刻只有一个线程可以操作缓冲区，避免竞态条件
3. 生产者：调用 `sem_wait` 确认有空位后，获取互斥锁并将数据写入 `buffer[in]`。完成写入后通过 `sem_post` 增加产品计数，通知消费者可以读取
4. 消费者：调用 `sem_wait` 确认有产品后，获取互斥锁从 `buffer[out]` 取出数据。处理完毕后通过 `sem_post` 增加空位计数，通知生产者缓冲区已有新空间
5. 通过 `(index + 1) % BUFFER_SIZE` 的取模运算，实现固定大小数组的循环利用，使 `in` 和 `out` 指针在缓冲区内首尾相连地循环移动

*task_4 截图*
![[Pasted image 20251223154452.png]]

### task_6 在 Linux 下模拟哲学家就餐，提供死锁和非死锁解法
task_6_gui.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <time.h>
#include <ncurses.h>
#include <signal.h>

#define PHILOSOPHER_NUM 5

// ============================================================================
// 开关配置：
// 0 = 【死锁演示模式】(拿到左筷子后强制停顿 1s)
// 1 = 【非死锁解法模式】(使用 trylock 策略)
#define ENABLE_NO_DEADLOCK_SOLUTION 1
// ============================================================================

typedef enum {
    STATE_THINKING,    // 思考 (Blue)
    STATE_HUNGRY,      // 饿了/等左筷子 (Yellow)
    STATE_GOT_LEFT,    // 拿到了左筷子/等右筷子 (Magenta)
    STATE_EATING,      // 吃饭 (Green)
    STATE_GIVE_UP      // 放弃并放下筷子 (Red blink)
} State;

pthread_mutex_t chopsticks[PHILOSOPHER_NUM];
pthread_mutex_t screen_lock;
State philo_states[PHILOSOPHER_NUM];

void random_sleep(int min_ms, int max_ms) {
    int sleep_micros = (rand() % (max_ms - min_ms + 1) + min_ms) * 1000;
    usleep(sleep_micros);
}

void draw_interface() {
    pthread_mutex_lock(&screen_lock);

    mvprintw(1, 2, "=== Philosopher's Dining (Ncurses GUI) ===");
    if (ENABLE_NO_DEADLOCK_SOLUTION)
        mvprintw(3, 2, "Mode: [NO DEADLOCK] (TryLock)");
    else
        mvprintw(3, 2, "Mode: [DEADLOCK DEMO] (Force Wait 1s)");

    mvprintw(5, 5, "ID   | Left Fork | Status            | Right Fork");
    mvprintw(6, 5, "-----|-----------|-------------------|-----------");

    for (int i = 0; i < PHILOSOPHER_NUM; i++) {
        int row = 8 + i * 2;
        mvprintw(row, 5, "[P%d]", i);
        mvprintw(row, 12, "%d", i);

        move(row, 24);
        switch (philo_states[i]) {
            case STATE_THINKING:
                attron(COLOR_PAIR(1)); printw(" Thinking...      "); attroff(COLOR_PAIR(1)); break;
            case STATE_HUNGRY:
                attron(COLOR_PAIR(2)); printw(" Waiting Left...  "); attroff(COLOR_PAIR(2)); break;
            case STATE_GOT_LEFT:
                attron(COLOR_PAIR(3)); printw(" HAS LEFT > WAIT  "); attroff(COLOR_PAIR(3)); break;
            case STATE_EATING:
                attron(COLOR_PAIR(4)); printw(" ** EATING **     "); attroff(COLOR_PAIR(4)); break;
            case STATE_GIVE_UP:
                attron(COLOR_PAIR(5)); printw(" !! GIVE UP !!    "); attroff(COLOR_PAIR(5)); break;
        }

        mvprintw(row, 44, "%d", (i + 1) % PHILOSOPHER_NUM);
    }

    mvprintw(20, 2, "Press Ctrl+C to exit.");
    refresh();
    pthread_mutex_unlock(&screen_lock);
}

void update_state(int id, State s) {
    philo_states[id] = s;
    draw_interface();
}

void* philosopher(void* arg) {
    int id = *(int*)arg;
    int left = id;
    int right = (id + 1) % PHILOSOPHER_NUM;

    while (1) {
#if ENABLE_NO_DEADLOCK_SOLUTION
        // ================= 【非死锁模式】 =================
        update_state(id, STATE_THINKING);
        random_sleep(100, 500); // 符合要求：100ms-500ms

        update_state(id, STATE_HUNGRY);
        // 尝试拿左边
        if (pthread_mutex_lock(&chopsticks[left]) == 0) {
            update_state(id, STATE_GOT_LEFT);
            random_sleep(100, 500); // 模拟拿起的动作

            // 尝试拿右边 (TryLock)
            if (pthread_mutex_trylock(&chopsticks[right]) == 0) {
                update_state(id, STATE_EATING);
                random_sleep(100, 500); // 符合要求：吃饭 100ms-500ms

                pthread_mutex_unlock(&chopsticks[right]);
                // 放下右筷子后，状态暂回左手持有（瞬间）
                update_state(id, STATE_GOT_LEFT);
            } else {
                // 拿不到，放弃
                update_state(id, STATE_GIVE_UP);
                random_sleep(100, 500); // 展示放弃状态
            }
            pthread_mutex_unlock(&chopsticks[left]);

            // 放弃后稍作等待
            random_sleep(100, 500);
        }
#else
        // ================= 【死锁模式】 =================
        update_state(id, STATE_THINKING);
        random_sleep(100, 500); // 符合要求：100ms-500ms

        update_state(id, STATE_HUNGRY);

        // 1. 拿左边
        pthread_mutex_lock(&chopsticks[left]);
        update_state(id, STATE_GOT_LEFT);

        // 【致命停顿】：拿到左筷子后，强制等1秒
        sleep(1);

        // 2. 拿右边 (死锁发生点)
        pthread_mutex_lock(&chopsticks[right]);

        update_state(id, STATE_EATING);
        random_sleep(100, 500); // 符合要求：吃饭 100ms-500ms

        pthread_mutex_unlock(&chopsticks[right]);
        pthread_mutex_unlock(&chopsticks[left]);
#endif
    }
    return NULL;
}

void finish(int sig) {
    endwin();
    exit(0);
}

int main() {
    signal(SIGINT, finish);

    initscr();
    cbreak();
    noecho();
    curs_set(0);
    start_color();

    init_pair(1, COLOR_BLUE, COLOR_BLACK);
    init_pair(2, COLOR_YELLOW, COLOR_BLACK);
    init_pair(3, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(4, COLOR_GREEN, COLOR_BLACK);
    init_pair(5, COLOR_RED, COLOR_BLACK);

    srand(time(NULL));
    pthread_mutex_init(&screen_lock, NULL);

    pthread_t philo[PHILOSOPHER_NUM];
    int ids[PHILOSOPHER_NUM];

    for (int i = 0; i < PHILOSOPHER_NUM; i++) {
        pthread_mutex_init(&chopsticks[i], NULL);
    }

    draw_interface();

    for (int i = 0; i < PHILOSOPHER_NUM; i++) {
        ids[i] = i;
        if (pthread_create(&philo[i], NULL, philosopher, &ids[i]) != 0) {
            endwin();
            perror("Create thread failed");
            return 1;
        }
    }

    for (int i = 0; i < PHILOSOPHER_NUM; i++) {
        pthread_join(philo[i], NULL);
    }

    endwin();
    return 0;
}
```
gcc task_6_gui.c -o task_6_gui -lpthread -lncurses

利用 `ncurses` 库构建字符图形界面，实时显示每个哲学家的状态（思考、饥饿、持有左筷子、进食、放弃）。通过 `screen_lock` 确保多线程刷新界面时不会产生乱序

- 死锁
1. 哲学家先调用 `pthread_mutex_lock` 锁定左手筷子，随后强制执行 `sleep(1)`
2. 通过 `sleep(1)` 确保所有哲学家都已成功持有左手筷子，强制死锁（不加这个 `sleep(1)` 的话可能得等很久才会出现死锁）
3. 哲学家再次调用 `pthread_mutex_lock` 锁定右手筷子。由于右侧筷子已被邻座哲学家作为“左手筷子”持有且不释放，导致所有线程永久阻塞

- 非死锁
1. 哲学家锁定左手筷子后，改用 `pthread_mutex_trylock` 尝试获取右手筷子
2. 如果右手筷子已被占用，`trylock` 会立即返回失败，哲学家随后会通过 `pthread_mutex_unlock` 释放已持有的左手筷子

*task_6 截图*
死锁：
![[Pasted image 20251223154600.png]]

非死锁：
![[Pasted image 20251223154530.png]]